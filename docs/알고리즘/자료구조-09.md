
---
layout: default
title: 이진탐색트리
parent: 자료구조
grand_parent: 알고리즘
nav_order: 9

---

## 스레드 이진 트리  
- 이진트리에 있는 NULL 링크를 이용해, **순환 호출 없이도** 트리의 노드들을 순회할 수 있는 트리이다!  
- 정의 : NULL 링크에, 중위 순회때의 후속 노드인 중위 후속자를 저장시켜놓은 트리   

### 스레드 이진 트리의 구현 (single threaded)  
- 단말노드와 비단말노드의 구별을 위해 **is_thread** 필드가 필요하다!  
- is_thread 가 TRUE 이면, right 은 **중위후속자**, 즉 노드의 오른쪽 위의 노드를 가르킨다.  
- is_thread 가 FALSE 이면, right 은 오른쪽 자식을 가리키는 링크가 된다.  

이 스레드 이진트리의 자료구조는 다음과 같다.  
```c
typedef struct TreeNode {
    int data;
    struct TreeNode *left, *right;
    int is_thread; //만약 오른쪽 링크가 스레드이면 TRUE  
} TreeNode;
```

## 이진탐색트리: 용어  
탐색이란: 레코드의 집합에서 특정한 레코드를 찾아내는 작업  
- 레코드 : 필드들의 집합, 구조체를 의미한다!  

### 레코드 관련 용어  
이 부분은 웹 개발에서도 많이 활용되기 때문에 필수적인 개념이라고 생각한다!  
    - 레코드는 보통 **key**라고 불리는 필드에 의해 식별된다.  
    - 고유(unique)한 값의 Key를 **primary key**라고 부른다. 예. 구조체의 학번, 주민등록번호 등  
    - 탐색 작업 : 이러한 Key가 입력되어 특정한 값을 가진 레코드를 찾게 된다!  
                --> **이진 탐색 트리는 탐색 작업에 효율적인 자료구조를 제공한다!!**  
    - 필드(field): 멤버(member )또는 원소(element) --> 필드 1: 학번, 필드 2: 이름, 필드 3: 주소 와 같은 개념이다.    
    - 테이블 : 레코드의 집합을 의미

구조 사진:  
자료구조-09-01.png

## 이진탐색트리: 정의  
- 이진탐색트리에서, 모든 원소의 키(key)는 유일하고, 고유한 값이다.  
- 항상 `key(왼쪽 서브 트리)의 값 < key(루트노드) < key(오른쪽 서브 트리)의 값 `의 룰이 적용되며, 잊지 말아야 할 점은 왼쪽과 오른쪽 서브 트리도! 그 자체만으로 이진 탐색 트리이다!  
- 이러한 룰로 이진탐색트리가 구성되기 때문에, **중위순회**를 하게 되면 자동적으로 **오름차순**으로 그 노드의 값들이 정렬되게 된다..!!  

## 이진탐색트리: 탐색연산  
- 주어진 탐색키 값과 루트 노드의 키 값을 비교함  
    - 맨 위에 18이 루트이고, 12를 찾으려고 하는 거라면 **왼쪽 자식**부터 탐색한다.  
    - 그 아래 자식은 7이다. 그렇다면 탐색하고자 하는 12는 7보다 크기 때문에 **오른쪽 자식부터** 탐색을 다시 한다. 
    - 비교한 결과가 같으면 **탐색 성공**, 끝난다!  

## 이진탐색트리: 삽입연산  
- 좋은 삽입 연산 알고리즘의 기준은, 구조 변경이 **최소화**되는 트리이다!  
- 삽입을 하기 위해서는!! **무조건 먼저 탐색**을 하는 것이 기본이다!  
- 탐색에 실패한 위치, 즉 NULL 값이 return 되는 지점이 새로운 노드를 삽입하는 위치이다!  
- 삽입은 없는 것을 만들어내는 것, 수정이 아니다!  

## 이진탐색트리의 성능분석  
- 최선 : 이진 트리가 **균형적**으로 생성되어 있는 경우  
- 최악 : 한쪽으로 치우친 **경사이진트리**의 경우 