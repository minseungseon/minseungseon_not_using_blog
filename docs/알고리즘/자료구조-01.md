---
layout: default
title: 자료구조 기본 개념  
parent: 자료구조
grand_parent: 알고리즘
nav_order: 1

---

## 자료구조란?  
컴퓨터과학에서 자료(Data)에의 효율적인 접근과 수정을 가능하게 하는 자료의 조직, 관리, 저장을 의미한다!  
자료를 구조적으로 표현하는 방식과 이를 구현하는데 필요한 알고리즘을 논하는 기초이론이다.  
더 간단히 말하여,  
**프로그램에서 자료를 정리하여 저장하는 구조**이다.  

## 알고리즘이란?  
문제를 해결하기 위한 절차나 방법을 의미한다. 특정한 작업을 수행하는, 명확하고 유효한 명령어들의 유한한 단계적인 절차를 의미한다.  
알고리즘은 **조건**이 있다!  
  
### 알고리즘이기 위한 조건:  
  1. 입력  
  2. 출력  
  3. 명확성  
  4. 유한성  
  5. 유효성  
  
### 알고리즘 명세 방법:  
  1. 자연어  
  2. 흐름도  
  3. 유사코드(pseudocode) : **가장 많이 쓰이는 방식**이다.  
  4. 프로그래밍 언어 : **가장 정확**한 방법이다!  



## 추상데이터 타입  
객체의 명세와 그 연산의 명세가 각각 **객체의 표현과 연산의 구현으로부터 각각 분리된 자료형** 을 의미한다.  
딱히 **구현 방법을 명시하고 있지 않다**는 점에서 자료 구조와 다르다!  
*배열, 연결 리스트는 추상자료형이 아닌, 실제로 구현된 자료구조이다.*  
그렇다면 **추상자료형의 예시**는 무엇일까?    
### 추상자료형 예시  
  1. 복소수  
  2. 리스트  
  3. 스택  
  4. 큐  
  5. 우선순위 큐  
  6. 트리  
  7. 맵  
  8. 집합  
이 있다~~!  
  
많이 들어보긴 했지만.. 이제 자료구조를 시작하는 입장에서 두려운 리스트이다..ㅎㅎ  
  
### 추상자료형 명시법  
추상데이터를 정의할 때에는 `::==`를 사용한다.  
```c
Set Create(s) ::== 공집합기호 
```


## 저장 유형 정리  
일반적으로 **자동 저장 유형** 사용을 권장한다!  
변수의 값이 함수 호출이 끝난 후에도 그 값이 유지되어야 한다면, **지역 정적**으로 저장한다.  
만약 많은 함수에서 공유되어야한다면, **외부 참조 변수** 이다.  
| **저장유형** | **키워드** | **정의 되는 위치**| **범위** | **생존 시간** |  
| :--------: | :--------: | :--------: | :--------: | :--------: |  
|자동|auto |함수 내부 |지역 |임시 |  
|레지스터 |register |함수 내부 |지역 |임시 |
|정적 지역 |static |함수 내부 |지역 |영구 |
|전역 |없음 |함수 외부 |모든 소스 파일 |영구 |
| 정적 전역|static |함수 외부 |하나의 소스 파일 |영구 |
|외부 참조 |extern | 함수외부|모든 소스파일 |영구 |  

## volatile 지정자  
**휘발성**이라는 의미이다.  
하드웨어가 수시로 변수의 값을 변경하는 경우에 사용됨    
```c
volatile int io_port; //하드웨어와 연결된 변수  

void wait(void){
  io_port = 0;
  while (io_port != 255); //하드웨어가 바뀌면,io_port 값에 적용됨  
}
```

  
## 순환(recursion)  
자기 자신을 호출 하는 것은 **순환**이라고 한다.  

```c
int factorial(int n) {
  if(n <= 1) return (1);
  else return(n*factorial(n-1));
}
```

## 포인터  
가장 중요하다고 강조하신 포인터!  
정의: 어떤 데이터가 저장된 **메모리 주소**를 담고 있는 변수  

포인터 변수를 어떤 타입(자료형)으로 선언하던지 간에!! **포인터 변수 자체의 크기는 4byte의 크기를 갖는다!!**  
  
### 포인터와 관련된 연산자  
### & 연산자와 * 연산자  
& : 주소 연산자로서, **변수의 주소**를 의미한다.  
* : 간접참조 연산자(indirect addressing)로서, **포인터가 가르키는 주소**를 의미함  
    따라서, *는 포인터가 가리키는 곳의 **값**을 나타내게 된다.  
      
### 포인터 변수의 사용법  
| **포인터 변수의 사용** | **의미** |   
|:---------------:|:------:|  
| `p=&i` | 변수 i의 주소를 포인터 변수 p에 저장 |  
| `printf("%p", p);` | 포인터 변수 p에 저장된 값(**주소**)를 출력 |  
| `printf("%d", *p);` | 포인터 변수 p가 가리키는 주소에 **저장된 값, value**를 출력 |  
| `*p=4;` | 포인터 변수 p가 가리키는 주소에 **저장된 값을 4로 대체** |  

### 주의사항  
- 포인터를 선언한 후에, ( *)를 사용하기 전에, **포인터는 반드시 먼저 초기화해야한다**  
- 포인터가 아무것도 가리키고 있지 않다면, **NULL**로 초기화하는게 바람직하다!  
  `int *p = NULL`  
  이렇게 해주지 않으면, 즉, NULL 포인터를 가지고 간접 참조하면, **하드웨어로 감지**할 수 있다.  


### 포인터의 연산  
포인터를 **1 증가시킨다**의 의미는, **포인터 타입**에 해당하는 **Byte 수**만큼 포인터 변수 값을 증가시키는 것이다.  
즉,  
char 타입은 바이트 수가 1이다.  
`char *p; p++;` 를 하게 되면, 포인터 p의 내용을 1만큼 증가시키게 된다.  
short 타입은 바이트 수가 2이다.  
`short *p; p++;` 를 하게 되면, 포인터 p의 내용을 2만큼 증가시키게 된다.  

  
이와 똑같이, int는 4, float도 4, 그리고 double은 8이 증가하게 된다!  

## 인수 전달 방법  
call by reference, call by value 가 있다!  

1. **call by value**  
: 인수를 함수에 전달하면, 새롭게 생성된 매개변수에 **전달받은 값**이 복사되어 저장된다!  

```c  
#include <stdio.h>

void swap(int x, int y);
int main (void) {
    int a=10, b=20;
    printf("swap 전: a= %d, b= %d\n",a,b);
    
    swap(a, b);
    printf("swap 후: a= %d, b= %d\n",a,b);
    return 0;
}
void swap(int x, int y) {
    int temp;
    temp = x;
    x=y;
    y=temp;
    
}
```

이렇게 짜게 되면, 출력은 : `swap 전: a= 10, b= 20 swap 후: a= 10, b= 20` 으로,  
그 값이 달라지지 않는다.  
그 이유는 원본데이터는 수정이 안되기 때문이다.  


2. **call by reference**
: 인수로 전달받은 값을 복사하는 것이 아닌, 전달받은 원본 데이터에 대한 **참보 변수(인수의 주소)**를 매개변수에 전달/복사한다.  
  따라서, 그 포인터가 가르키는 그 자체가 복사되기 때문에, 함수 내부에서 값이 변경되면 함수 밖의 **원본 데이터**도 같이 바뀌게 된다.  

```c
#include <stdio.h>

void swap(int *pointer_x, int *pointer_y);

int main (void) {
    int a=10, b=20;
    printf("swap 전: a= %d, b= %d\n",a,b);
    
    swap(&a, &b);
    printf("swap 후: a= %d, b= %d\n",a,b);
    return 0;
}

void swap(int *pointer_x, int *pointer_y) {
    int temp;
    temp = *pointer_x;
    *pointer_x = *pointer_y;
    *pointer_y=temp;
    
}

```

이렇게 주소값으로 접근하여 그 주소에 저장되어 있는 원본 데이터를 바꾸게 되면,  
`swap 전: a= 10, b= 20
swap 후: a= 20, b= 10`  
올바르게 a와 b의 값이 바뀌어서 출력되는 것을 확인 할 수 있다.  


### 포인터 반환할 때의 주의점  
**지역변수의 주소**를 반환하면, 그 함수가 종료될 때 사라지기 때문에 오류가 발생한다!!  
주소가 호출자에게 반환되고, 바로 그 포인터가 소멸하게 되면, **최종적으로 할당되지 않은 메모리(dangling pointer)** 가 된다.  
그리고 이러한 함수를 호출자가 사용하게 되면 문제가 발생 할 수 있다.  
  
따라서, 반환하는 주소가 **유효한 변수** 가 되도록 하는 것이 중요하다!!  

해서는 안되는 예시:
  
```c
int *add(int x, int y){
  int result;
  result = x+y;
  
  return &result; //이런식의 지역변수 주소 반환은 에러를 일으킬 수 있다!
```
  


